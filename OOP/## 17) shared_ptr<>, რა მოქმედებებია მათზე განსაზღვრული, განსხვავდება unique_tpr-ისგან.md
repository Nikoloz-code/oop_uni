# _**shared_ptr<>, რა მოქმედებებია მათზე განსაზღვრული, განსხვავდება unique_tpr-ისგან.**_

std::shared_ptr არის ისეთი ჭკვიანი პოინტერი, რომლის საშუალებით რამოდენიმე პოინტერის საკუთრებაში შეიძლება იყოს ერთი ობიექტი. ანუ მონიშნული ობიექტების არსებობის ხანგრძლივობა იმართება საზიარო საკუთრების საფუძველზე. სწორედ ამის გამო, არც ერთი std::shared_ptr არ **_ფლობს_** ობიექტს.
std::shared_ptr-ს გააჩნია მთვლელი, რომელიც ითვლის თუ რამდენი shared_ptr მიუთითებს რაიმე მისამართს. კონსტრუქტორი მას ზრდის, დესტრუქტორი მას ამცირებს, ხოლო ასლის მინიჭების დროს კი ამცირებს და ზრდის ერთდროულად. ანუ, თუ ორი განსხვავებული საზიარო პოინტერი გვაქ, მინიჭება s1 = s2 (სადად s1 და s2 არის std::shared_ptr) ცვლის s1-ის ისე რომ უყურებდეს s2-ს. ამიტომაც s1 მცირდება, ხოლო s2 იზრდება.
___
std::shared_ptr-ს არ შეუძლია მასივებთან მუშაობა, რაც std::unique_ptr-ს შეუძლია. ეს არის იმიტომ რომ shared_ptr არის დაპროგრამებული მხოლოდ ერთ ობიექტზე მიმთითებელი პოინტერებისთვის.
___
საზიარო პოინტერი შეიძლება ორნაირად შევქმნათ:
```cpp
  std::shared_ptr<int> p = std::make_shared<int>(77);
  // ან
  std::shared_ptr<int> q(new int(99));
```
> [!IMPORTANT]
> std::make_shared - ის გამოყენება უკეთესია, რდგან იგი ერთდროულად აკეთებს ობიექტსაც და რეფერენსების მთვლელსაც, ანუ new ოპერატორს გამოიძახებს ერთხელ.

განსაკუთრებული შემთხვევაა როდესაც საზიაროს პოინტერს ვქმნით არსებული ობიექტისგან. ამ დროს პოინტერი შეიქმნის საკუთრებაში ამ ობიექტის
ასლს:
```cpp
  int a(99);
  shared_ptr<int> p = make_shared<int>(a);
  cout << "Shared object " << p->data << endl;
```
___
საზიარო პოინტერების ასლების შექმნა ადვილად ხდება. ასლირების დროს იზრდება თითოეულის მითითებების მთვლელი:
```cpp
  std::shared_ptr<noisyInt> p = std::make_shared<noisyInt>(77);
  std::shared_ptr<noisyInt> q(p);
```
> [!IMPORTANT]
> თავიდან p და q არის 1, მაგრამ ასლირების დროს, ორივე გახდება 2.
___
std::shared_ptr-ების გადაადგილებაც შეიძლება. თუ გვაქ ორი საზიარო პოინტერი, რომლის მნიშვნელობებია 3.15 და 11.21, ხოლო მათი მთვლელებია 2 და 1, თუ გადავაადგილეთ ერთი პოინტერი მეორეში, მაშინ პირველი პოინტერის მნიშნველობა იქნება განუსაზღვრელი და მისი მთვლელი გახდება 0, ხოლო მეორე პოინტერის მთვლელი იქნება 2 და მისი მნიშვნელობა გახდევა 3.15, ანუ პირველის თავდაპირველი მთვლელი და მნიშვნელი. მაგალითად:
```cpp
int main()
{
    std::shared_ptr<double> p1(new double(3.15));
    std::shared_ptr<double> p2 = p1;
    
    std::shared_ptr<double> p3(new double(11.21));
    
    p3 = std::move(p1);
    
    std::cout << "*p3= " << *p3 << " " << "p3.use_count()=" << p3.use_count() << std::endl;
    std::cout << "p1.use_count()=" << p1.use_count() << std::endl << std::endl;
}
```
> [!IMPORTANT]
> ```
> *p1= 3.15 p1.use_count()=2
> *p3= 11.21 p3.use_count()=1
> 
> *p1= 8.24353e-315 p1.use_count()=0
> *p3= 3.15 p3.use_count()=2
> ```
___
```reset()``` ფუნქციის საშუალებით კი შეგვიძლია საზიარო პოინტერი გავხადოთ ნულ პოინტერად და მთვლელის გავხადოთ 0. თუ არც ერთი სხვა პოინტერი არ უყურებს იმ ობიექტს რომელსაც უყურებს ის საზიარო პოინტერი რომელზეც ვიყენებთ ფუნქციას, მაშინ ის ობიექტი იშლება.
```cpp
int main()
{
  std::shared_ptr<int> sp0 = std::make_shared<int>(12);
  auto sp1 = sp0;
  std::cout << sp0.use_count() << '\t' << sp1.use_count() << '\t' << *sp1 << '\n'; // 2  2  12 
  sp0.reset();
  std::cout << sp0.use_count() << '\t' << sp1.use_count() << '\t' << *sp1 << '\n'; // 0  1  12
  sp1.reset();
  std::cout << sp0.use_count() << '\t' << sp1.use_count() << '\t' << *sp1 << '\n'; // 2  2  ??
}
```
> [!IMPORTANT]
> ```
> 1) 2  2  12 
> 
> 2) 0  1  12 
> 
> 3) 0  0  ?? (undefined behaviour) 
> ```
