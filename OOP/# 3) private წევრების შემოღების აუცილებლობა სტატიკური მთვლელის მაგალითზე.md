# **_private წევრების შემოღების აუცილებლობა სტატიკური მთვლელის მაგალითზე._**
--
ობიექტზე ორიენტირებული პროგრამირების სტილი დიდ მნიშვნელობას ანიჭებს ინფორმაციის დაფარვას. იგი აუცილებელია როდესაც გვინდა კლასის შესახებ გარკვეული მონაცემების დაცვა ისე, რომ ობიექტებიდან ვერ მივწვდეთ მას. ასეთ შემთხვევებში დაცული ინფორმაციის ნახვა მხოლოდ ამ მიზნით შექმნილი საზიარო (public) ფუნქციის საშუალებით ხდება. 
___
ბევრ ამოცანაში სასარგებლოა ვიცოდეთ, თუ მოცემული კლასის რამდენი ობიექტია მოქმედი, ანუ რამდენი ობიექტია შექმნილი. ყველაზე გავრცელებული და ლამაზი გზა იმაში მდგომარეობს, რომ ```შეიქმნას მთვლელისთვის ცვლადი, რომელიც საერთო იქნება ყველა არსებული კლასის ობიექტისთვის static-ის გამოყენებით და რომლის მნიშვნელობა გაიზრდება ერთით ყოველი ახალი ობიექტის კონსტრუქტირების მომენტში, ხოლო დესტრუქციის დროს კი ერთით შემცირდება.``` სწორედ ამის გამო, არავითარი აუცილებლობაა, რომ რომელიმე ობიექტი მისწვდეს ამ ცვლადს, ამიტომაც იგი იქნება private წევრი.

 **_სტატიკური მთვლელის მოვლა._**
--

სტატიკურმა მთვლელმა ადვილად შეიძლება შექმნას გაუთვალისწინებელი სირთულეები, თუ არ ვიზრუნებთ ყველა შესაძლო სცენარის დამუშავებაზე. თუ ჩვენ გამოვიყენეთ კონსტრუქტორი **_რომელიც პროგრამისტმა არ დააპროგრამა_**, C++ თვითონ ქმნის ```ნაგულისხმევ კონსტრუქტორს```. ცხადია, იგი ამ დროს ვერ ითვალისწინებს ბევრ დეტალს, მათ შორის სტატიკური ცვლადების მოვლის საკითხს. სწორედ ამის გამო, აუცილებელია რომ პროგრამისტმა დაამატოს ყველა შესაძლო კონსტრუქტორი, სადაც პროგრამისტი პროგრამისტი ერთით ზრდის სტატიკურ მთვლელს.
