# **_unique_ptr<>, რა მოქმედებებია მათზე განსაზღვრული, გაუქმების საკითხი._**

unique_ptr<> არის C++11-ის მიერ შემოთავაზებული ჭკვიანი პოინტერების ერთ-ერთი სახეობა.
როდესაც რაიმე ფუნქციაში ვქმნით ჭკვიან პოინტერს, იგი ფუნქციის ბოლოში თვითონ აუქმებს თავის თავს. ანუ, ჭკვიანი პოინტერები შექმნილია მეხსიერების გაჟონვის თავიდან ასაცილებლად.
___
თუ ჩვენ დინამიურად გვინდა შევქნათ ნებისმიერი მონაცემის ტიპი, ```new```-ს მაგივრად ვიყენებთ ```make_unique<მონაცემთა_ტიპი>(მონაცემი);```
> [!IMPORTANT]
> ორივენაირად შეგვიძლია დავაპროგრამოთ დინამიური მონაცემის ტიპი.
```cpp
int main()
{
  unique_ptr<noisyInt> p = make_unique<int>(77);
  cout << "First object " << p->data << endl;
}
```
___
თუ ჩვენ გვინდა ჭკვიან პოინტერში შექმნილ დინამიურ მონაცემის მისამართი თან იყოს მეორე პოინტერის მისამართიც, მაშინ შეგვიძლია გამოვიყენოთ ```get()```.
```cpp
int main()
{
  unique_ptr<int> p = make_unique<int>(77);

  int* rp = p.get();

  std::cout << "rp is: " << *rp << '\n';
  std::cout << "p is: " << *p << '\n';
}
```
> [!CAUTION]
> პოინტერის შიგნით რა მონაცემიც იყო დაკავშირებული წაიშლება პროგრამის ბოლოს (ანუ მოხდება ```delete p; delete rp;```), მაგრამ პოინტერები არ არიან განულებული, ამიტომაც შეგიძლიათ ჩაამატოთ ```rp = nullptr; p = nullptr;``` პროგრამის ბოლოს.

> [!IMPORTANT]
> ჩვენ არ შეგვიძლია ერთი ჭკვიანი პოინტერში შექმნილი დინამიური მონაცემი იყოს დაკავშირებული მეორე ჭვკიან პოინტერთან. როდესაც ვიყენებთ get(), უნდა ვიყენებდეთ ჩვეულებრივი, ნედლი პოინტერი.
# ეს ნაწილი გასასწორებელია, ჯერ არ წაიკითხოთ.
___
თუ ჩვენ გვინდა ჭკვიან პოინტერში შექმნილ დინამიურ მონაცემის მისამართი და თან რომ პირველი პოინტერი გაუქმდეს, მაშინ შეგვიძლია გამოვიყენოთ ```release()```.
```cpp
int main()
{
  unique_ptr<int> p = make_unique<int>(77);

  int* rp = p.release();
  if(p == nullptr) std::cout << "p is NULL" << '\n';
  std::cout << "rp is: " << *rp << '\n';
}
```
> [!IMPORTANT]
> აქ p გახდება nullptr, რის გამო დაიბეჭდება ```p is NULL```, ხოლო rp-ში კი მოცემული მონაცემი დარჩება.
___
