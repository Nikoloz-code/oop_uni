# **_unique_ptr<>, რა მოქმედებებია მათზე განსაზღვრული, გაუქმების საკითხი._**

unique_ptr<> არის C++11-ის მიერ შემოთავაზებული ჭკვიანი პოინტერების ერთ-ერთი სახეობა.
როდესაც რაიმე ფუნქციაში ვქმნით ჭკვიან პოინტერს, იგი ფუნქციის ბოლოში თვითონ აუქმებს თავის თავს. ანუ, ჭკვიანი პოინტერები შექმნილია მეხსიერების გაჟონვის თავიდან ასაცილებლად.
___
თუ ჩვენ დინამიურად გვინდა შევქნათ ნებისმიერი მონაცემის ტიპი, ```new```-ს მაგივრად ვიყენებთ ```make_unique<მონაცემთა_ტიპი>(მონაცემი);```
> [!IMPORTANT]
> ორივენაირად შეგვიძლია დავაპროგრამოთ დინამიური მონაცემის ტიპი.
```cpp
int main()
{
  std::unique_ptr<int> p = std::make_unique<int>(77);
  
  std::unique_ptr<int> q(new int(99));
}
```
___
თუ ჩვენ გვინდა ჭკვიან პოინტერში შეფუთული ნედლი პოინტერი **(raw pointer)** თან იყოს მეორე ნედლი პოინტერის მისამართიც, მაშინ შეგვიძლია გამოვიყენოთ ```get()```.
```cpp
int main()
{
  std::unique_ptr<int> p = std::make_unique<int>(77);

  int* rp = p.get();

  std::cout << "rp is: " << *rp << '\n';
  std::cout << "p is: " << *p << '\n';
}
```
> [!CAUTION]
> პოინტერის შიგნით რა მონაცემიც იყო დაკავშირებული წაიშლება პროგრამის ბოლოს (ანუ მოხდება ```delete p; delete rp;```), მაგრამ პოინტერები არ არიან განულებული, ამიტომაც შეგიძლიათ ჩაამატოთ ```rp = nullptr; p = nullptr;``` პროგრამის ბოლოს.

> [!IMPORTANT]
> ჩვენ არ შეგვიძლია ერთი ჭკვიანი პოინტერში შექმნილი დინამიური მონაცემი იყოს დაკავშირებული მეორე ჭვკიან პოინტერთან. როდესაც ვიყენებთ get(), უნდა ვიყენებდეთ ჩვეულებრივი, ნედლი პოინტერი.
___
თუ ჩვენ გვინდა ჭკვიან პოინტერი გავაუქმოთ ისე, რომ შიგნით შეფუთული ნედლი პოინტერი არ გაუქმდეს და თავისი თავი დააბრუნოს, მაშინ ვიყენებთ ```release()``` ფუნქციას. აუცილებელია იმის ხსენება, რომ რადგან შიგნით შეფუთული ნედლი პოინტერი არ გაუქმდა, ჩვენ release-ის გამოყენების დროს, შეგვიძლია მივანიჭოთ დაბრუნებული ნედლი პოინტერი რაიმე სხვა ნედლ პოინტერს:
```cpp
int main()
{
  std::unique_ptr<int> p = std::make_unique<int>(77);

  int* rp = p.release();
  if(p == nullptr) std::cout << "p is NULL" << '\n';
  std::cout << "rp is: " << *rp << '\n';
}
```
> [!IMPORTANT]
> აქ p გახდება nullptr, რის გამო დაიბეჭდება ```p is NULL```, ხოლო rp-ში კი მოცემული მონაცემი დარჩება.
___
თუ ჩვენ გვინდა ერთი ჭკვიანი პოინტერში შეფუთული ნედლი პოინტერის საკუთრების უფლება გადავცეთ რაიმე სხვა ჭკვიან პოინტერს რომელსაც საკუთრება არ გააჩნია, მაშინ შეგვიძლია გამოვიყენოთ ```move()``` ფუნქცია.
```cpp
#include <iostream>
#include <memory>

int main()
{
    std::unique_ptr<int> p = std::make_unique<int>(55);
    std::unique_ptr<int> u;
    
    u = std::move(p);
    
    if (u != nullptr) std::cout << "*u: " << *u << std::endl;
    if (p != nullptr) std::cout << "*p: " << *p << std::endl;
}
```
> [!IMPORTANT]
> ამ კოდში დაიბეჭდება მარტო ```*u: 55```, რადგან p პოინტერი საკუთრების უფლების გადაცემის შემდეგ ხდება ნულოვანი პოინტერი.
