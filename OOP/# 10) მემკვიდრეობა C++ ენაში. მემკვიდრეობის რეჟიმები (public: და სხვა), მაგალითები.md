# მემკვიდრეობა C++ ენაში. მემკვიდრეობის რეჟიმები (public: და სხვა),  მაგალითები.

მემკვიდრეობა არის კლასის უნარი რომ სხვა კლასისგან შექმნას თვისებები და მახასიათებლები. სწორედ ეს არის ობიექტზე ორიენტირებული პროგრამირების ყველაზე აუცილებელი თვისება. კლასებს, რომლებიც სხვა კლასისგან იღებს მახასიათებლებს, ვეძახით **წარმოებულ კლასებს**, ხოლო იმ კლასს რისგანაც მემკვიდრეობით იღებს თვისებებს — **ფუძე-კლასს**. პროგრამირებაში ხშირია ისეთი შემთხვევები როდესაც დასამუშავებელ კომპონენეტებს აქვთ მსგავსი ატრიბუტები, ანუ მონაცემები და მეთოდები. ასეთი შემთხვევის დროს კარგი აზრია, რომ ავაგოთ რაიმე კლასი რომელსაც აქვს ეს ყველა ატრიბუტი, ხოლო სხვა კლასები კი მათ მემკვიდრეობით მიიღებენ. ამით ჩვენ ამ ატრიბუტების თავიდან შექმნა აღარ დაგვჭირდება და ნაკლებ მეხსიერებასაც ვიყენებთ.

```cpp
//წარმოებული კლასის ფუნქციის სტრუქტურა
class წარმოებული_კლასის_სახელი : მემკვიდრეობის_რეჟიმი ფუძე_კლასის_სახელი 
{
 	// წარმოებული კლასის ტანი
};
```

მემკვიდრეობის რეჟიმი არის **public** ან **private**. ამ რეჟიმების საშუალებით, წარმოებული კლასი მემკვიდრეობით იღებს იმ მონაცემებს რომლებიც მოთავსებულია ფუძე-კლასის წვდომის რეჟიმებში. 
___
მაგალითისთვის, მოდით შევქმნათ ფუძე კლასი რომლის მეთოდი არის **public** წვდომის რეჟიმში და შევქმნათ წარმოებული კლასი რომელიც მემკვიდრეობით იღებს ფუძე კლასის **public** მეთოდს:

```cpp
class parentClass {
public:
  void printText(std::string text){
    std::cout << text << std::endl;
  }
};

class childClass : public parentClass{

};

int main(){
  childClass obj;
  obj.printText("Hello World");
}
```
> [!IMPORTANT]
> Output იქნება ჩვეულებრივ Hello World, რადგან public წევრებისადმი წვდომა შეიძლება კლასის ობიექტიდან, ფუძე-კლასის და წარმოებული კლასების შიგნით.

ჩვენ რომ მემკვიდრეობის რეჟიმში მივუთითოთ **private** და შევქმნათ საჯარო ფუძე-კლასის მეთოდის გეთერ ფუნქცია წარმოებულ კლასში:

```cpp
class parentClass {
private:
  void printText(std::string text){
    std::cout << text << std::endl;
  }
};

class childClass : private parentClass{
public:
  void getPrintFunction(std::string text){
    printText(text);
  }
};

int main(){
  childClass obj;
  obj.getPrintFunction("Hello World");
}
```
> [!CAUTION]
> ჩვენ რომ ეს კოდი გავუშვათ, იგი არ იმუშავებს, რადგან კერძო წევრებისადმი წვდომა შეუძლებელია წარმოებული კლასებიდან ან კლასის ობიექტებიდან.

თუ ჩვენ გვინდა რომ ფუძე-კლასის წევრებთან კავშირი შეუძლებელი იყოს მის ობიექტებიდან, მაგრამ წარმოებულ კლასს რომ ჰქონდას მასთან წვდომა, გამოვიყენებთ მესამე, **protected** წვდომის რეჟიმს. მოდით მაღლა მოცემული კოდი თავიდან დავწეროთ მის გამოყენებით:
```cpp
class parentClass {
protected:
  void printText(std::string text){
    std::cout << text << std::endl;
  }
};

class childClass : protected parentClass{
public:
  void getPrintFunction(std::string text){
    printText(text);
  }
};

int main(){
  childClass obj;
  obj.getPrintFunction("Hello World");
}
```

> [!IMPORTANT]
> ეს კოდი იმუშავებს და დაბეჭდავს სათანადო სტრინგს. მაგრამ, რომ ვცადოთ ცალკე გამოვიძახოთ ფუძე-კლასის print ფუნქცია, იგი არ იმუშავებს. რადგან **protected** წვდომის რეჟიმში, წვდომა შესაძლებელია თავისივე კლასში და წარმოებულ კლასებში, მაგრამ არა კლასის ობიექტებიდან.

მაშასადამე:
- **public** წვდომის რეჟიმში მოთავსებული წევრებთან კავშირი შესაძლებელია წარმოებულ კლასებიდან და ფუძე-კლასის ობიექტებიდან.
- **private** წვდომის რეჟიმში მოთავსებული წევრებთან კავშირი შესაძლებელია მარტო კლასის შიგნით, ხოლო კლასის ობიექტს კი წვდომა შეუძლია **public**-ში მოცემულ **გეთერ** და **სეთერ** ფუნქციების დახმარებით
- **protected** წვდომის რეჟიმში მოთავსებული წევრებთან კავშირი შესაძლებელია კლასის შიგნით და წარმოებულ კლასებში, მაგრამ შეუძლებელია კლასის გარეთ.
